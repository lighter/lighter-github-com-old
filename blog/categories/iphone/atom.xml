<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iPhone | Lighter's Blog]]></title>
  <link href="http://lighter.tw/blog/categories/iphone/atom.xml" rel="self"/>
  <link href="http://lighter.tw/"/>
  <updated>2013-04-02T14:54:06+08:00</updated>
  <id>http://lighter.tw/</id>
  <author>
    <name><![CDATA[Willy lighter]]></name>
    <email><![CDATA[apple.xva@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JSON資料於TableView與Pull Refresh]]></title>
    <link href="http://lighter.tw/blog/2013/01/10/jsonzi-liao-yu-tableviewyu-pull-refresh/"/>
    <updated>2013-01-10T17:11:00+08:00</updated>
    <id>http://lighter.tw/blog/2013/01/10/jsonzi-liao-yu-tableviewyu-pull-refresh</id>
    <content type="html"><![CDATA[<p>我透過JSON的方式來取得資料，並且可以從網路上取得，並且當資料有變動的時候，透過<code>Table View</code>向下拉的方式來更新資料。我的JSON資料是透過php程式來撰寫。首先先來建置一個簡單的資料表。如下圖，在<code>Table View</code>的部分會呈現名字，當點選名字後會看到該名字的電話號碼。</p>

<p>{% img /images/json/json1.png 216px 390px %}</p>

<!-- more -->

<h3 id="php">php程式碼</h3>
<p>{% codeblock lang:php %}
&lt;?php
include(‘db.php’);
$query = mysql_query(‘SELECT * FROM user’);
$json_data = array();
while($row = mysql_fetch_assoc($query)) {
  $json_data[] = $row;
}
echo json_encode($json_data);
{% endcodeblock %}</p>

<p><strong>Step 1.</strong>建立<code>Master Detail Application</code>專案。</p>

<p>建立完成專案後先開始編輯<code>MasterViewController.h</code>。建立一個<code>NSMutableArray</code>型態的<code>json_array</code>物件。</p>

<p>{% codeblock MasterViewController.h lang:objc %}
#import &lt;UIKit/UIKit.h&gt;
@interface MasterViewController : UITableViewController
@property (strong, nonatomic) NSMutableArray *json_array;
@end
{% endcodeblock %}</p>

<p><strong>Step 2.</strong>編輯<code>MasterViewController.m</code></p>

<p>在<code>viewDidLoad</code>方法內加入下面的程式碼</p>

<p>{% codeblock MasterViewController.m lang:objc %}
@implementation MasterViewController
@synthesize json_array;
- (void)viewDidLoad
{
    [super viewDidLoad];
    //1
     NSURL *url = [NSURL
                  URLWithString:@”http://XXX.XXX/json.php”];
    //2
    NSData *jsonData=[NSData dataWithContentsOfURL:url];
    NSError *error = nil;</p>

<pre><code>//3
json_array = [NSJSONSerialization JSONObjectWithData:jsonData options:
        NSJSONReadingMutableContainers error:&amp;error]; } {% endcodeblock %}
</code></pre>

<ol>
  <li>在上面的程式碼一開始定義一個<code>NSURL</code>類別的<code>url</code>變數，該變數很明顯的可以看到要連接的網頁網址！</li>
  <li>將<code>url</code>網址的資料存放到<code>NSData</code>類別的<code>jsonData</code>變數中。</li>
  <li>接著將取得到的結果放到<code>json</code>陣列中，當中可以看到<code>options:NSJSONReadingMutableContainers</code>這段，這意思是將<code>jsonData</code>取得的<code>JSON</code>資料轉為<code>NSMutableDictionary</code>，之後再取得名稱或電話時可以<code>objecForKey</code>的方式來取得。</li>
</ol>

<p>接著修改<code>Table View Cell</code>的回傳個數</p>

<p>{% codeblock MasterViewController.m lang:objc %}
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return json_array.count;
}
{% endcodeblock %}</p>

<p>修改<code>Cell</code>顯示的文字，這邊需要透過<code>objectForKey</code>方法指定Key值為。</p>

<p>{% codeblock MasterViewController.m lang:objc %}
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@”Cell” forIndexPath:indexPath];
    cell.textLabel.text = [[json_array objectAtIndex:indexPath.row] objectForKey:@”u_name”];
    return cell;
}
{% endcodeblock %}</p>

<p>傳遞參數也需要修改一下。
{% codeblock MasterViewController.m lang:objc %}
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{
    if ([[segue identifier] isEqualToString:@”showDetail”]) {
        NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow];
        [[segue destinationViewController] setDetailItem:[json_array
                                                          objectAtIndex:indexPath.row]];
    }
}
{% endcodeblock %}</p>

<p>將<code>JSON</code>的資料放入<code>Table View</code>中會如下圖所示(資料內容有新增修改過)。</p>

<p>{% img /images/json/json2.png 216px 390px %}
{% img /images/json/json3.png 216px 390px %}</p>

<p>接下來當我<code>MySql</code>有新增資料，或是刪除資料時，我想要同步更新到<code>Table View</code>中，所以我使用了<code>PullToRefresh</code>這個套件。網路上蠻多人都說<code>EGOTableViewPullRefresh</code>這套，但是它似乎不支援<code>ARC</code>，所以我就改用別的了。</p>

<p>這個套件使用上很簡單！首先下載好它的檔案<a href="https://github.com/sonnyparlin/PullToRefresh">Here</a>，並加入專案內。</p>

<p>{% img /images/json/json4.png %}</p>

<p>接著加入<code>QuartzCore.framework</code>。</p>

<p>{% img /images/json/json5.png %}</p>

<p>修改<code>MasterViewController.h</code>，程式碼如下：
{% codeblock MasterViewController.m lang:objc %}
#import &lt;UIKit/UIKit.h&gt;
#import “PullToRefreshView.h” //1</p>

<p>@interface MasterViewController : UITableViewController<pulltorefreshviewdelegate> //2
@property (strong, nonatomic) NSMutableArray *json_array;
@property (strong, nonatomic) PullToRefreshView *pull; //3
@end
{% endcodeblock %}</pulltorefreshviewdelegate></p>

<p>回到<code>MasterViewController.m</code>在<code>viewDidLoad</code>將<code>PullToRefresh</code>加入到<code>Table View</code>中。
{% codeblock MasterViewController.m lang:objc %}
@implementation MasterViewController
@synthesize json_array, pull;
- (void)viewDidLoad
{
    [super viewDidLoad];
	// Do any additional setup after loading the view, typically from a nib.
    NSURL *url = [NSURL
                  URLWithString:@”http://lighter.cp22.secserverpros.com/lighter127/JSON/json.php”];
    NSData *jsonData=[NSData dataWithContentsOfURL:url];
    NSError *error = nil;
    json_array = [NSJSONSerialization JSONObjectWithData:jsonData options:
            NSJSONReadingMutableContainers error:&amp;error];</p>

<pre><code>//pull refresh
pull = [[PullToRefreshView alloc] initWithScrollView:(UIScrollView *) self.tableView];
[pull setDelegate:self];
[self.tableView addSubview:pull]; } {% endcodeblock %}
</code></pre>

<p>當<code>Table View</code>往下拉的時候會呼叫<code>pullToRefreshViewShouldRefresh:</code>方法。這裡我會呼叫另一個自定的方法<code>reloadTableData</code>，而在該方法內我重新再連一次<code>json.php</code>的網頁並更新<code>json_array</code>的內容，最後才呼叫<code>tableView</code>的<code>reloadData</code>。</p>

<p>當資料更新結束後，呼叫<code>finishedLoading</code>方法，結束<code>Pull Refresh</code>的動作。</p>

<p>{% codeblock MasterViewController.m lang:objc %}
#pragma mark - Table View Pull Refresh</p>

<ul>
  <li>
    <p>(void)pullToRefreshViewShouldRefresh:(PullToRefreshView *)view;
{
  [self reloadTableData];
}</p>
  </li>
  <li>
    <p>(void)reloadTableData
{
  NSURL *url = [NSURL
                URLWithString:@”http://XXX.XXX/json.php”];
  NSData *jsonData=[NSData dataWithContentsOfURL:url];
  NSError *error = nil;
  json_array = [NSJSONSerialization JSONObjectWithData:jsonData options:
                NSJSONReadingMutableContainers error:&amp;error];
  [self.tableView reloadData];
  [pull finishedLoading];
}
{% endcodeblock %}</p>
  </li>
</ul>

<blockquote>
  <p>註：由於向下捲動<code>Table View</code>的速度比我截圖速度快….我就放棄了…</p>
</blockquote>

<h1 id="section">參考資料</h1>
<ol>
  <li><a href="http://sonnyparlin.com/2011/12/pulltorefresh-ios-5-and-arc-tutorial/">PullToRefresh iOS 5 and ARC Tutorial</a></li>
  <li><a href="https://github.com/sonnyparlin/PullToRefresh">PullToRefresh</a></li>
  <li><a href="https://github.com/enormego/EGOTableViewPullRefresh">EGOTableViewPullRefresh</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Image]]></title>
    <link href="http://lighter.tw/blog/2012/11/06/core-image/"/>
    <updated>2012-11-06T19:01:00+08:00</updated>
    <id>http://lighter.tw/blog/2012/11/06/core-image</id>
    <content type="html"><![CDATA[<p><code>Core Image</code>是一項Mac OS X的技術，利用機器的繪圖處理器來作影像相關特效。於2004年8月的世界開發者大會(WWDC)中展示。(引用自<a href="http://zh.wikipedia.org/wiki/Core_Image">維基百科Core Image</a>)</p>

<p>我們可以透過<code>Core Image</code>的框架(framework)來調整圖片的顏色、亮度…等。而Core Image包含了很多的濾鏡的效果，這些都可以在Document中找到。</p>

<p>而<code>Core Image</code>有幾個重要的類別</p>

<ol>
  <li><code>CIContext</code>: 所有Core Image的處理都透過CIContext完成。這有點類似於Core Graphics或OpenGL的Context。</li>
  <li><code>CIImage</code>: 該類別可持有圖片檔案。它可透過UIImage、圖片檔案或者是像素檔案來建立。</li>
  <li><code>CIFilter</code>: 濾鏡類別擁有字典(dictionary)，可以指定濾鏡效果的，例如自然飽和度(vibrance)、色彩反轉(color inversion)、剪裁(cropping)…等。</li>
</ol>

<!-- more -->

<p><strong>Step 1. 加入<code>CoreImage.framework</code></strong></p>

<p>加入CoreImage.framework，並且準備好一張圖片加入到專案中。</p>

<p>{% img /images/CoreImage/1.png %}</p>

<p><strong>Step 2. 編輯<code>MainStoryboard.storyboard</code></strong></p>

<p>加入</p>

<ol>
  <li>UIImageView</li>
  <li>Round Rect Button</li>
</ol>

<p>{% img /images/CoreImage/2.png %}</p>

<p>這邊加入3個按鈕，分別用來呈現不同的效果。</p>

<p><strong>Step 3. 編輯ViewController</strong></p>

<p>首先編輯<code>ViewController.h</code>，程式碼如下：</p>

<p>{% codeblock ViewController.h lang:objc %}
#import &lt;UIKit/UIKit.h&gt;</p>

<p>@interface ViewController : UIViewController
{
    CIContext *context;
    CIFilter *filter;
    CIImage *inputImage;    //輸入的圖片
    CIImage *outputImage;   //輸出濾鏡效果的圖片
}
@property (strong, nonatomic) IBOutlet UIImageView *imageView;
- (IBAction)filter1:(id)sender; //濾鏡效果1
- (IBAction)filter2:(id)sender; //濾鏡效果2
- (IBAction)filter3:(id)sender; //濾鏡效果3
@end
{% endcodeblock %}</p>

<p><code>ViewController.m</code>的程式碼如下：</p>

<p>首先在<code>viewDidLoad</code>方法指定圖片給<code>imageView</code>。
{% codeblock ViewController.m lang:objc %}
@implementation ViewController
@synthesize imageView;
- (void)viewDidLoad
{
    [super viewDidLoad];
    UIImage *img = [UIImage imageNamed:@”test.jpg”];
    imageView.image = img;
    inputImage = [[CIImage alloc] initWithImage:[UIImage imageNamed:@”test.jpg”]];
}
. . . . . 略
{% endcodeblock %}</p>

<p>接著開始撰寫濾鏡效果的按鈕方法，這邊只介紹一個，程式碼如下：</p>

<p>{% codeblock ViewController.m lang:objc %}
- (IBAction)filter1:(id)sender {
	//1
    inputImage = [[CIImage alloc] initWithImage:[UIImage imageNamed:@”test.jpg”]];</p>

<pre><code>//2
context = [CIContext contextWithOptions:nil];

//3
filter = [CIFilter filterWithName:@"CIColorPosterize"];
[filter setValue:inputImage forKey:@"inputImage"];
[filter setValue:[NSNumber numberWithFloat:3.0] forKey:@"inputLevels"];

 //4
outputImage = [filter outputImage];
imageView.image = [UIImage imageWithCGImage:[context createCGImage:outputImage fromRect:outputImage.extent]]; } {% endcodeblock %}
</code></pre>

<ol>
  <li>指定輸入的圖片。</li>
  <li><code>CIContext</code>指定要使用CPU或是GPU來處理，這裡使用預設值就可以，所以指定為<code>nil</code>。</li>
  <li>設定濾鏡效果，後面會介紹如何知道有哪些濾鏡效果及參數的設定。</li>
  <li>透過<code>outputImage</code>這個方法可以取得濾鏡效果處理後的<code>CIImage</code>，最後將處理過後的圖片指定給<code>imageView</code>。</li>
</ol>

<p><strong>Step 4. 編譯專案</strong></p>

<p>在一開始可以看到<code>UIImageView</code>的原始圖案，點下濾鏡效果按鈕後可以看到圖片改變了！！</p>

<p>{% img /images/CoreImage/3.png 216px %}
{% img /images/CoreImage/4.png 216px %}</p>

<p>就這麼簡單吧！但是一開始困擾我的問題是，我怎麼知道CoreImage有提供哪些濾鏡效果呢？其實這在Document都有詳細的說明，但要如何尋找呢？下面的方法其實我也是看過人家影片教學，才知道有這樣的尋找方式！我覺得非常方便。</p>

<p>首先開啟到<code>ViewController.m</code>，並找到<code>CIFilter</code>，為了強調要選取它，所以在此將它反白，不然將游標移到<code>CIFilter</code>上就可以了。接著選取到右上方的<code>Show Quick Help Inspector</code>，在下方可以看到<code>Core Image Filter Reference</code>，如下圖：</p>

<p>{% img /images/CoreImage/5.png %}</p>

<p>點選<code>Core Image Filter Reference</code>後會跳出一個新的視窗，會顯示<code>Filter</code>效果有哪些，如下圖：</p>

<p>{% img /images/CoreImage/6.png %}</p>

<p>接著先找尋到先前使用到的<code>CIColorPosterize</code>這個濾鏡效果，點選下去</p>

<p>{% img /images/CoreImage/7.png %}</p>

<p>點選後會看到<code>CIColorPosterize</code>這個濾鏡效果的參數有哪些，這個效果的參數只有兩個，分別為<code>inputImage</code>與<code>inputLevels</code>，除了參數，下方也會有簡單的圖示呈現該濾鏡的效果如何，如下圖：</p>

<p>{% img /images/CoreImage/8.png %}</p>

<p>在這邊可以看到這兩個參數跟<code>forKey</code>值很像，這邊的方式就是透過setValue指定參數的值，在指定<code>forKey</code>值來指設定參數，所以當濾鏡效果不同時，會有不一樣的<code>forKey</code>值，這都需要參考到Document的說明！</p>

<p>{% codeblock lang:objc %}
[filter setValue:inputImage forKey:@”inputImage”];
[filter setValue:[NSNumber numberWithFloat:3.0] forKey:@”inputLevels”];
{% endcodeblock %}</p>

<h1 id="section">參考資料</h1>
<ol>
  <li><a href="http://www.raywenderlich.com/5689/beginning-core-image-in-ios-5">Beginning Core Image in iOS 5 Tutorial</a></li>
  <li><a href="http://www.raywenderlich.com/22167/beginning-core-image-in-ios-6">Beginning Core Image in iOS 6</a></li>
  <li><a href="http://itouchs.blogspot.tw/2011/12/filter4cam-core-image-tutorial.html">Filter4Cam 學習之 Core Image Tutorial</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Data Relationship]]></title>
    <link href="http://lighter.tw/blog/2012/11/03/core-data-relationship/"/>
    <updated>2012-11-03T17:40:00+08:00</updated>
    <id>http://lighter.tw/blog/2012/11/03/core-data-relationship</id>
    <content type="html"><![CDATA[<p><code>Core Data</code>在前面的範例中並沒有使用到<code>Relationship</code>，如果你的資料結構是需要使用到兩個資料表時，這時可以透過<code>Relationship</code>，而且操作起來…我覺得方便很多！假如有表1跟表2是有相關連了，以往我在操作MySQL的時候，會先取得表1的Key值，在拿表1的Key值到表2查詢，這樣等於我要做兩次的SQL查詢(可能有更好的作法吧，我沒有特別去研究…)，所以當我用<code>Core Data</code>的時候，覺得這是一個很方便又快速的作法。</p>

<p>接下來我們建立的資料表如下圖。</p>

<p>{% img /images/CoreDataRelationship/1.png %}</p>

<!-- more -->

<p><code>UserInfo</code>只用來記錄名字，<code>UserDetail</code>則用來記錄該名字的電話、地址、E-mail，而下面<code>Relationship</code>分別為<code>detail</code>跟<code>info</code>。</p>

<p><strong>Step 1.編輯<code>xcdatamodeled</code>檔案。</strong></p>

<p><code>Entity</code>、<code>Attribute</code>、<code>Relationship</code>的新增就跳過了；這邊需注意的是<code>Relationship</code>設定，除了<code>Destination</code>還須設定<code>Inverse</code>，如下圖。</p>

<p>{% img /images/CoreDataRelationship/2.png %}</p>

<p>{% img /images/CoreDataRelationship/3.png %}</p>

<p><strong>Step 2.新增<code>Model</code>檔案。</strong></p>

<p>點選<code>UserInfo</code>，在對著專案<code>右鍵</code>/<code>New File</code>/<code>iOS</code>/<code>Core Data</code>/<code>NSManagedObject subclass</code>/<code>Next</code>，接著自動就會產生UserInfo.h與.m的檔案；<code>UserDetail</code>一樣的操作，完成後應該會有四個檔案，分別為UserInfo與UserDetail的.h與.m檔案。</p>

<p>{% img /images/CoreDataRelationship/5.png %}</p>

<p><strong>Step 3.編輯<code>MainStoryboard.storyboard</code>檔案。</strong></p>

<p>完成如下圖，新增的時候要輸入姓名、email、電話、地址；顯示則是顯示這四個值。</p>

<p>{% img /images/CoreDataRelationship/4.png %}</p>

<p><strong>Step 4.修改<code>MasterViewController.m</code>。</strong></p>

<p>記得要把<code>viewDidLoad</code>方法內的執行內容清除，僅需保留<code>[super viewDidLoad];</code>。</p>

<p>找到下列三段程式碼，分別修改成對應的<code>Entity</code>名稱與<code>Key</code>值。</p>

<p>{% codeblock MasterViewController.m lang:objc %}
//1
NSEntityDescription *entity = [NSEntityDescription entityForName:@”UserInfo” inManagedObjectContext:self.managedObjectContext];</p>

<p>//2
NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@”name” ascending:NO];</p>

<p>//3
cell.textLabel.text = [[object valueForKey:@”name”] description];
{% endcodeblock %}</p>

<p><strong>Step 5.新增<code>AddViewController</code>檔案。</strong></p>

<p>新增一個<code>UIViewController</code>的檔案，class名稱為<code>AddViewController</code>。
{% img /images/CoreDataRelationship/6.png %}</p>

<p>指定該檔案為新增資料頁面的<code>Class</code>。
{% img /images/CoreDataRelationship/7.png %}</p>

<p><strong>Step 6.編輯<code>AddViewController.h</code>。</strong></p>

<p>編輯程式如下
{% codeblock AddViewController.h lang:objc %}
#import &lt;UIKit/UIKit.h&gt;
#import “AppDelegate.h”
#import “UserInfo.h”
#import “UserDetail.h”</p>

<p>@interface AddViewController : UIViewController
@property (strong, nonatomic) IBOutlet UITextField *name;
@property (strong, nonatomic) IBOutlet UITextField *phone;
@property (strong, nonatomic) IBOutlet UITextField *email;
@property (strong, nonatomic) IBOutlet UITextField *address;
- (IBAction)save:(id)sender;</p>

<p>@property (strong, nonatomic) AppDelegate *app;
@end
{% endcodeblock %}</p>

<p>分別定義四個<code>UITextField</code>的<code>property</code>，一個<code>IBAtcion</code>的save:方法；<code>AppDelegate</code>如同之前說的是要使用<code>AppDelegate</code>內的<code>managedObjectContext</code>。</p>

<p><strong>Step 7.編輯AddViewController.m。</strong></p>

<p>編輯程式如下
{% codeblock AddViewController.m lang:objc %}
@synthesize name, email, phone, address, app;</p>

<ul>
  <li>
    <p>(IBAction)save:(id)sender {
app = [[UIApplication sharedApplication] delegate];
NSManagedObjectContext *context = [app managedObjectContext];</p>

    <p>UserInfo *info = [NSEntityDescription insertNewObjectForEntityForName:@”UserInfo” inManagedObjectContext:context];
info.name = name.text;</p>

    <p>UserDetail *detail = [NSEntityDescription insertNewObjectForEntityForName:@”UserDetail” inManagedObjectContext:context];
detail.address = address.text;
detail.email = email.text;
detail.phone = phone.text;
info.detail = detail; //關連</p>

    <p>NSError *error;
if (![context save:&amp;error]) {
  NSLog(@”Save Error : %@”, [error localizedDescription]);
} else {
  [self.navigationController popViewControllerAnimated:YES];
}
}
{% endcodeblock %}</p>
  </li>
</ul>

<p>補上<code>synthesize</code>！。這邊可以看到定義一個<code>UserInfo</code>與<code>UserDetail</code>的類別變數，分別將TextField的值指定給個別對應的<code>Attribute</code>，這邊可以注意到的是第14行，是透過這樣方式指定兩個表格的對應關連！</p>

<p><strong>Step 8.修改<code>MasterViewController.m</code>。</strong></p>

<p>找到<code>prepareForSegue</code>方法，修改的程式如下
{% codeblock MasterViewController.m lang:objc %}
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{
    if ([[segue identifier] isEqualToString:@”showDetail”]) {
        NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow];</p>

<pre><code>    //修改成UserInfo
    UserInfo *object = [[self fetchedResultsController] objectAtIndexPath:indexPath];
    [[segue destinationViewController] setDetailItem:object];
} } {% endcodeblock %}
</code></pre>

<p><strong>Step 9.修改<code>DetailViewController.h</code>。</strong></p>

<p>編輯程式碼如下</p>

<p>{% codeblock DetailViewController.h lang:objc %}
#import &lt;UIKit/UIKit.h&gt;
#import “UserInfo.h”</p>

<p>@interface DetailViewController : UIViewController</p>

<p>//修改detailItem的形態為UserInfo
@property (strong, nonatomic) UserInfo *detailItem;</p>

<p>@property (weak, nonatomic) IBOutlet UILabel *detailDescriptionLabel;</p>

<p>//多定義3個UILabel元件
@property (strong, nonatomic) IBOutlet UILabel *detailEmail;
@property (strong, nonatomic) IBOutlet UILabel *detailPhone;
@property (strong, nonatomic) IBOutlet UILabel *detailAddress;</p>

<p>@end
{% endcodeblock %}</p>

<p><strong>Step 10.修改<code>DetailViewController.m</code>。</strong></p>

<p>找到<code>configureView</code>方法，修改程式碼如下</p>

<p>{% codeblock DetailViewController.m lang:objc %}
- (void)configureView
{
    // Update the user interface for the detail item.</p>

<p>if (self.detailItem) {
    self.detailDescriptionLabel.text = [[self.detailItem valueForKey:@”name”] description];
    self.detailEmail.text = self.detailItem.detail.email;
    self.detailPhone.text = self.detailItem.detail.phone;
    self.detailAddress.text = self.detailItem.detail.address;
  }
}
{% endcodeblock %}</p>

<p>如果上述的程式碼有問題的話，不妨檢查一下<code>UserInfo.h</code>的檔案，這邊我發現到自動產生的檔案，他產生的形態並沒有如預期的型態，<code>detail</code>的形態應該是<code>UserDeatail</code>，程式碼如下</p>

<p>{% codeblock UserInfo.h lang:objc %}
#import &lt;Foundation/Foundation.h&gt;
#import &lt;CoreData/CoreData.h&gt;
#import “UserDetail.h”</p>

<p>@interface UserInfo : NSManagedObject</p>

<p>@property (nonatomic, retain) NSString * name;
@property (nonatomic, retain) UserDetail *detail;</p>

<p>@end
{% endcodeblock %}</p>

<p><strong>Step 11.編譯專案。</strong></p>

<p>最後編譯專案時，記得檢查一下IBOutlet的關聯是否都建立了，如果沒問題，就可以開始新增資料與檢視資料了。</p>

<p>{% img /images/CoreDataRelationship/8.png 216px 390px %}
{% img /images/CoreDataRelationship/9.png 216px 390px %}
{% img /images/CoreDataRelationship/10.png 216px 390px %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Data-Part3]]></title>
    <link href="http://lighter.tw/blog/2012/11/01/core-data-part3/"/>
    <updated>2012-11-01T11:48:00+08:00</updated>
    <id>http://lighter.tw/blog/2012/11/01/core-data-part3</id>
    <content type="html"><![CDATA[<p>延續<a href="http://lighter.tw/blog/2012/06/02/core-data-part2/">Core Data-Part2</a>的文章，現在要加入的是搜尋，當Table View中有越來越多的資料後，要尋找某比資料的話，用眼睛尋找是一件很累人的事情！所以可以透過輸入關鍵字來搜尋，接下來就來完成這個範例。</p>

<p>{% img /images/CoreDataWithSearch/1.png 216px 390px %}
{% img /images/CoreDataWithSearch/2.png 216px 390px %}</p>

<!-- more -->

<p><strong>Step 1.加入<code>Search Bar and Search Display Controller</code></strong></p>

<p>加入<code>Search Bar and Search Display Controller</code>到<code>Table View</code>上方。</p>

<p>{%img /images/CoreDataWithSearch/3.png %}</p>

<p><strong>Step 2.編輯MasterViewController.h檔案</strong></p>

<p>{% codeblock MasterViewController.h lang:objc %}
#import &lt;UIKit/UIKit.h&gt;
#import &lt;CoreData/CoreData.h&gt;</p>

<p>//1
#import “Phone.h”</p>

<p>//2
@interface MasterViewController : UITableViewController 
&lt;NSFetchedResultsControllerDelegate, UISearchDisplayDelegate, UISearchBarDelegate&gt;
{
  //3
  BOOL savedSearchTerm;
}</p>

<p>@property (strong, nonatomic) NSFetchedResultsController *fetchedResultsController;
@property (strong, nonatomic) NSManagedObjectContext *managedObjectContext;</p>

<p>//4
@property (nonatomic, retain) NSMutableArray *searchResults;</p>

<p>//5
@property (nonatomic, retain) NSIndexPath *indexP;</p>

<p>@end
{% endcodeblock %}</p>

<ol>
  <li>引入<code>Phone.h</code>。</li>
  <li>加入<code>UISearchDisplayDelegate</code>、<code>UISearchBarDelegate</code>兩個協定。</li>
  <li><code>saveSearchTerm</code>用來判斷是否為搜尋狀態。</li>
  <li><code>searchResults</code>陣列是用來儲存搜尋的結果。</li>
  <li><code>indexP</code>是用來取得搜尋結果，點選cell的索引值。</li>
</ol>

<p><strong>Step 3.編輯MasterViewController.m</strong></p>

<p>{% codeblock MasterViewController.m lang:objc %}
@synthesize indexP;
{% endcodeblock %}</p>

<p>補上<code>synthesize</code>。</p>

<p>{% codeblock MasterViewController.m lang:objc %}
//1
- (void)viewDidLoad
{
    [super viewDidLoad];
    self.searchResults = [NSMutableArray arrayWithCapacity:[[self.fetchedResultsController fetchedObjects] count]];
    [self.tableView reloadData];
}</p>

<p>//2
- (void)viewDidUnload
{
    [super viewDidUnload];
    self.searchResults = nil;
}
{% endcodeblock %}</p>

<ol>
  <li>在<code>viewDidLoad</code>方法內對<code>searchResults</code>初始化，並且重新整理<code>Table View</code>。</li>
  <li><code>viewDidUnload</code>方法內，將<code>searchResults</code>釋放掉。</li>
</ol>

<p>{% codeblock MasterViewController.m lang:objc %}
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
  if (tableView == self.searchDisplayController.searchResultsTableView) {
    return [self.searchResults count];
  }
  else {
    id <nsfetchedresultssectioninfo> sectionInfo = [[self.fetchedResultsController sections] objectAtIndex:section];
    return [sectionInfo numberOfObjects];
  }
}
{% endcodeblock %}</nsfetchedresultssectioninfo></p>

<p><code>Table View</code>的<code>cell</code>個數，在搜尋的時候會不一樣，因此<code>tableView:numberOfRowsInSection:</code>方法需要做修改。 </p>

<p>如上當<code>if</code>判斷式條件成立時，會回傳<code>searchResults</code>陣列的個數，否則就回傳原本<code>fetchedResultsController</code>的個數。</p>

<p>{% codeblock MasterViewController.m lang:objc %}
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@”Cell”];</p>

<pre><code>//1
if (cell == nil) {
  cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@"Cell"];
  cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator;
}

//2
Phone *phone = nil;
if (tableView == self.searchDisplayController.searchResultsTableView)
{
  phone = [self.searchResults objectAtIndex:indexPath.row];
}
else
{
  phone = [self.fetchedResultsController objectAtIndexPath:indexPath];
}

//3
cell.textLabel.text = phone.name;
return cell; } {% endcodeblock %}
</code></pre>

<ol>
  <li>這邊需要額外使用程式碼的方式定義一個<code>cell</code>，並且初始化，因為在搜尋的時候並不知道<code>Storyboard</code>中的<code>cell</code>。</li>
  <li>當<code>tableView</code>是在搜尋的狀態時，指定<code>searchResults</code>搜尋結果給<code>phone</code>，反之將<code>fetchedResultsController</code>指定給<code>phone</code>。</li>
  <li>這邊改成直接指定<code>cell</code>的文字為<code>phone.name</code>。</li>
</ol>

<p>{% codeblock MasterViewController.m lang:objc %}
#pragma mark -
#pragma mark UISearchDisplayController Delegate Methods</p>

<ul>
  <li>
    <p>(BOOL)searchDisplayController:(UISearchDisplayController *)controller shouldReloadTableForSearchString:(NSString *)searchString
{
[self filterContentForSearchText:searchString scope:@”All”];
savedSearchTerm = TRUE;
return YES;
}</p>
  </li>
  <li>
    <p>(BOOL)searchDisplayController:(UISearchDisplayController *)controller shouldReloadTableForSearchScope:(NSInteger)searchOption
{
[self filterContentForSearchText:[self.searchDisplayController.searchBar text] scope:@”All”];
savedSearchTerm = TRUE;
return YES;
}
-(void) searchDisplayControllerWillEndSearch:(UISearchDisplayController *)controller{
savedSearchTerm = TRUE;
}
{% endcodeblock %}</p>
  </li>
</ul>

<p>加入上述三個<code>UISearchDisplayController</code>的方法，並且指定<code>savedSearchTerm</code>為<code>TRUE</code>，其中可以看到<code>filterContentForSearchText:scope:</code>這個方法，該方法是用來根據您輸入的文字做搜尋的。</p>

<p>{% codeblock MasterViewController.m lang:objc %}
#pragma mark -
#pragma mark Content Filtering</p>

<ul>
  <li>(void)filterContentForSearchText:(NSString<em>)searchText scope:(NSString</em>)scope
{
  [self.searchResults removeAllObjects];
NSLog(@”search text: %@”, searchText);
  for (Phone *phone in [self.fetchedResultsController fetchedObjects])
  {
      if ([scope isEqualToString:@”All”] || [phone.name isEqualToString:scope])
      {
          NSComparisonResult result = [phone.name compare:searchText
                                           options:(NSCaseInsensitiveSearch|NSDiacriticInsensitiveSearch)
                                             range:NSMakeRange(0, [searchText length])];
    if (result == NSOrderedSame)
          {
              [self.searchResults addObject:phone];
    }
      }
  }
}
{% endcodeblock %}</li>
</ul>

<p>該方法會根據您輸入的字串，尋找到符合的結果！</p>

<p>{% codeblock MasterViewController.m lang:objc %}
//1
-(void) tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
  if (savedSearchTerm) {
    indexP = indexPath;
    [self performSegueWithIdentifier:@”showDetail” sender:self];
  }
}</p>

<p>//2
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{
    if ([[segue identifier] isEqualToString:@”showDetail”]) {
      if (savedSearchTerm) {
        NSManagedObject *object = [[self fetchedResultsController] objectAtIndexPath:indexP];
        [[segue destinationViewController] setDetailItem:object];
      } else {
        NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow];
        NSManagedObject *object = [[self fetchedResultsController] objectAtIndexPath:indexPath];
        [[segue destinationViewController] setDetailItem:object];
      }
    }
}
{% endcodeblock %}</p>

<ol>
  <li>當你搜尋完畢後要可以點選<code>cell</code>，然後看到該<code>cell</code>的細部資訊，所以透過<code>tableView:didSelectRowAtIndexPath:</code>方法可以取得你點選<code>cell</code>的<code>indexPath</code>索引值，將該值指定給<code>indexP</code>，在呼叫到<code>perforSegueWithIdentifier:sender:</code>方法。</li>
  <li>該方法就是要用來傳遞參數到<code>DetailViewController</code>的，一樣需要判斷是否在搜尋的狀態，然後再傳遞對應的索引值(<code>indexPath</code>或<code>indexP</code>)。</li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS With Dropbox]]></title>
    <link href="http://lighter.tw/blog/2012/10/28/ios-with-dropbox/"/>
    <updated>2012-10-28T00:38:00+08:00</updated>
    <id>http://lighter.tw/blog/2012/10/28/ios-with-dropbox</id>
    <content type="html"><![CDATA[<p>{% img /images/iPhoneWithDropbox/1.png %}</p>

<p>iPhone上已經有iCloud可以用來同步及備份資料了，但iCloud有空間的限制，而有在使用Dropbox的人，如果有參加一些特殊的活動或者是學生的身份，都可以多取得到一些額外的空間容量(或者是有邀請許多朋友加入也都可以額外增加空間)。雖然Dropbox官方的說明已經很清楚了，但是我還是記錄一下，免得之後要用忘記….</p>

<!-- more -->

<p><strong>Step 1.建立Single View Application專案</strong></p>

<p><strong>Step 2.編輯MainStroyboard.storyboard檔案</strong></p>

<p>這邊我使用三個<code>Round Rect Button</code>，分別用來建立檔案、檢驗檔案是否存在與上傳檔案</p>

<p>{% img /images/iPhoneWithDropbox/2.png %}</p>

<p><strong>Step 3.建置Dropbox App</strong></p>

<p>到Dropbox開發者<a href="https://www.dropbox.com/developers">網站</a>，建立一個新的App。建立完成後可以看到Dropbox根據這個App會給你一個<code>App key</code>與<code>App secret</code>，到時會需要這兩個值。</p>

<p>下載Dropbox的Framework，並且加入到Xcode專案；還有要加入<code>Security.framework</code>與<code>QuartzCore.framework</code>到專案中。</p>

<p>{% img /images/iPhoneWithDropbox/3.png %}</p>

<p><strong>Step 4.編輯AppDelegate.m</strong></p>

<p>在<code>AppDelegate.m</code>中加入下列程式碼</p>

<p>{% codeblock AppDelegate.m lang:objc %}
#import &lt;DropboxSDK/DropboxSDK.h&gt;
- (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
	DBSession</em> dbSession =
		[[DBSession alloc]
			initWithAppKey:@”APP_KEY”
			appSecret:@”APP_SECRET”
			root:ACCESS_TYPE]; // either kDBRootAppFolder or kDBRootDropbox
	[DBSession setSharedSession:dbSession];
	return YES;
}</p>

<ul>
  <li>(BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url {
if ([[DBSession sharedSession] handleOpenURL:url]) {
  if ([[DBSession sharedSession] isLinked]) {
    NSLog(@”App linked successfully!”);
    // At this point you can start making API calls
  }
  return YES;
}
// Add whatever other url handling code your app requires here
return NO;
}
{% endcodeblock %}</li>
</ul>

<p>**Step 5.編輯<code>專案名稱-Info.plist</code>檔案</p>

<p>使用<code>open source</code>開啟<code>專案名稱-Info.plist</code>，找到第一個<code><dict>&lt;/code&gt;在下方加入這段：</dict></code></p>

<p>{% codeblock 專案名稱-Info.plist lang:objc %}</p>
<key>CFBundleURLTypes</key>
<array>
    <dict>
        <key>CFBundleURLSchemes</key>
        <array>
            <string>db-APP_KEY</string>
        </array>
    </dict>
</array>
<p>{% endcodeblock %}</p>

<p>**Step 6.編輯ViewController</p>

<p>首先在<code>ViewController.h</code>程式碼如下：</p>

<p>{% codeblock ViewController.h lang:objc %}
#import &lt;UIKit/UIKit.h&gt;
#import &lt;DropboxSDK/DropboxSDK.h&gt;</p>

<p>@interface ViewController : UIViewController<dbrestclientdelegate>
{
  DBRestClient *restClient;
}
- (IBAction)loginDropbox:(id)sender;
- (IBAction)upload:(id)sender;
- (IBAction)creatFile:(id)sender;</dbrestclientdelegate></p>

<p>@end
{% endcodeblock %}</p>

<p>接著在<code>ViewController.m</code>撰寫三個方法的實作內容，並且撰寫一個<code>restClient</code>的getter方法。</p>

<p>{% codeblock ViewController.m lang:objc %}
- (DBRestClient *)restClient {
  if (!restClient) {
    restClient =
    [[DBRestClient alloc] initWithSession:[DBSession sharedSession]];
    restClient.delegate = self;
  }
  return restClient;
}</p>

<ul>
  <li>
    <p>(IBAction)loginDropbox:(id)sender {</p>

    <p>if (![[DBSession sharedSession] isLinked]) {
  [[DBSession sharedSession] linkFromController:self];
} else {
  NSLog(@”linked”);
}
}</p>
  </li>
  <li>
    <p>(IBAction)upload:(id)sender {</p>

    <p>NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *path = [[paths objectAtIndex:0]stringByAppendingPathComponent:@”file1.txt”];;
NSString *pathString = @”/”;
[self.restClient uploadFile:@”file1.txt” toPath:pathString fromPath:path];</p>
  </li>
</ul>

<p>}</p>

<ul>
  <li>
    <p>(IBAction)creatFile:(id)sender {
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *path = [[paths objectAtIndex:0]stringByAppendingPathComponent:@”file1.txt”];;</p>

    <p>// String to write
NSString *str = @”iPhone Developer Tips\nhttp://iPhoneDevelopTips,com”;
NSError *error;
// Write the file
[str writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:&amp;error];</p>

    <p>NSFileManager *filemgr;</p>

    <p>filemgr = [NSFileManager defaultManager];</p>

    <p>if ([filemgr fileExistsAtPath: path ] == YES)
  NSLog (@”File exists”);
else
  NSLog (@”File not found”);</p>
  </li>
</ul>

<p>}
{% endcodeblock %}</p>

<p><strong>Step 7.編譯專案</strong></p>

<p>點選<code>link dropbox</code>按鈕，跟Dropbox做連接；在點選<code>create &amp; check</code>按鈕建立檔案與確認檔案是否存在；最後才點選<code>upload</code>按鈕，將建立的檔案上傳到Dropbox。</p>
]]></content>
  </entry>
  
</feed>
