<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: NodeJS | Lighter's Blog]]></title>
  <link href="http://lighter.tw/blog/categories/nodejs/atom.xml" rel="self"/>
  <link href="http://lighter.tw/"/>
  <updated>2013-09-16T19:58:46+08:00</updated>
  <id>http://lighter.tw/</id>
  <author>
    <name><![CDATA[Willy lighter]]></name>
    <email><![CDATA[apple.xva@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[NodeJS 安裝]]></title>
    <link href="http://lighter.tw/blog/2013/03/31/nodejs-an-zhuang/"/>
    <updated>2013-03-31T08:31:00+08:00</updated>
    <id>http://lighter.tw/blog/2013/03/31/nodejs-an-zhuang</id>
    <content type="html"><![CDATA[<p>系統：Mountain Lion</p>

<p><a href="http://mxcl.github.com/homebrew/index_zh-tw.html">Homebrew</a>是一個Mac OS套件管理工具</p>

<p>因為Mac上預設都有安裝Ruby了，所以可以直接用以下的指令安裝</p>

<p>{%codeblock%}
&gt; ruby -e “$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)”
{%endcodeblock%}</p>

<ol>
  <li>
    <p>安裝node
{%codeblock%}
&gt; brew update
&gt; sudo brew install node
{%endcodeblock%}</p>
  </li>
  <li>
    <p>安裝npm
{% codeblock %}
&gt; sudo npm install express -g
{% endcodeblock %}</p>
  </li>
  <li>
    <p>修改npm PATH，開啟<code>~/.bash_profile</code>，加入以下的代碼
{% codeblock %}
export PATH=/usr/local/bin:$PATH:/usr/local/share/npm/bin
{% endcodeblock %}</p>
  </li>
  <li>
    <p>接著就可以使用<code>express</code>指令來建立專案了
{%codeblock%}
express new project
{%endcodeblock%}</p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[express with post/get/ajax]]></title>
    <link href="http://lighter.tw/blog/2013/02/04/express-with-post-slash-get-slash-ajax/"/>
    <updated>2013-02-04T16:55:00+08:00</updated>
    <id>http://lighter.tw/blog/2013/02/04/express-with-post-slash-get-slash-ajax</id>
    <content type="html"><![CDATA[<p>使用NodeJS版本為<code>v0.8.18</code></p>

<p>在終端機中輸入
{% codeblock %}
express test -e
{% endcodeblock %}</p>

<p>開啟<code>package.json</code>檔案，將版本都修改為<code>*</code>號。
{% codeblock lang:json %}
{
  “name”: “application-name”,
  “version”: “0.0.1”,
  “private”: true,
  “scripts”: {
    “start”: “node app”
  },
  “dependencies”: {
    “express”: “<em>”,
    “ejs”: “</em>”
  }
}
{% endcodeblock %}</p>

<p>完成後到終端機輸入
{% codeblock %}
npm install -l
{% endcodeblock %}</p>

<p>在<code>view</code>資料夾內新增<code>sign.ejs</code>與<code>sign2.ejs</code>兩個檔案，這兩個檔案是用來接收<code>post</code>與<code>get</code>的資料並且顯示出來。</p>

<p><code>index.ejs</code>程式碼如下
{% codeblock index.ejs lang:html %}
&lt;!DOCTYPE html&gt;</p>
<html>
  <head>
    <title>&lt;%= title %&gt;</title>
    <link rel="stylesheet" href="http://lighter.tw/stylesheets/style.css" />
    <script src="http://lighter.tw//ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
    <script type="text/javascript">
      jQuery(document).ready(function($) {
        $('#send').on('click',function(){
          var data = {
            'account': $('#ajax_account').val(),
            'pass': $('#ajax_pass').val()
          };
          $.post('/sign3', data ,function(data2) {
            $('#ajax').html(data2);
            console.log(data2);
          });
        });
      });

    </script>
  </head>
  <body>
    <h1>&lt;%= title %&gt;</h1>
    <p>Welcome to &lt;%= title %&gt;</p>
    <h1>GET Method</h1>
    <form action="/sign" method="GET">
      <table>
        <tr>
          <td>Accout<input type="text" name="account" /></td>
        </tr>
        <tr>
          <td>Password<input type="text" name="pass" /></td>
        </tr>
        <tr>
          <td><input type="submit" value="send" /></td>
        </tr>
      </table>
    </form>

    <h1>POST Method</h1>
    <form action="/sign2" method="POST">
      <table>
        <tr>
          <td>Account<input type="account" name="account" id="account" /></td>
        </tr>
        <tr>
          <td>Password<input type="pass" name="pass" id="pass" /></td>
        </tr>
        <tr>
          <td><input type="submit" value="send" /></td>
        </tr>
      </table>
    </form>

    <h1>AJAX Method</h1>
    <form action="#">
      <table>
        <tr>
          <td>Account<input type="account" name="account" id="ajax_account" /></td>
        </tr>
        <tr>
          <td>Password<input type="pass" name="pass" id="ajax_pass" /></td>
        </tr>
        <tr>
          <td><button type="button" id="send">send</button></td>
        </tr>
      </table>
    </form>

    <div id="ajax"></div>

  </body>
</html>
<p>{% endcodeblock %}</p>

<p>接著開啟根目錄下的<code>app.js</code>加入<code>form</code>的<code>action</code>方法進去。</p>

<p>{% codeblock app.js lang:js %}
app.get(‘/’, routes.index);
app.get(‘/sign’, routes.sign);
app.post(‘/sign2’, routes.sign2);
app.post(‘/sign3’, routes.sign3);
{%endcodeblock %}</p>

<p>定義好對應的方法後，在到<code>routes</code>資料夾內的<code>index.js</code>撰寫方法的執行內容，程式碼如下：</p>

<p>{% codeblock index.js lang:js %}
//GET Method
exports.sign = function(req, res){
  res.render(‘sign’, {
    title: ‘Show Result’,
    account: req.query.account,
    pass: req.query.pass
  });
};</p>

<p>//POST Method
exports.sign2 = function(req, res){
  res.render(‘sign2’, {
    title: ‘Show Result’,
    account: req.body.account,
    pass: req.body.pass
  });
};</p>

<p>//AJAX Method
exports.sign3 = function(req, res) {
  res.send(‘Account:’ + req.body.account + ‘, Pass:’ + req.body.pass)
};
{% endcodeblock %}</p>

<p><code>sign.ejs</code>與<code>sign2.ejs</code>的內容分別為：</p>

<p>{% codeblock sign.ejs lang:html %}
&lt;!DOCTYPE html&gt;</p>
<html>
  <head>
    <title>&lt;%= title %&gt;</title>
    <link rel="stylesheet" href="http://lighter.tw/stylesheets/style.css" />
  </head>
  <body>
    <h1>Show Result</h1>
    <p>Accout:&lt;%= account%&gt;</p>
    <p>Password:&lt;%= pass%&gt;</p>
  </body>
</html>

<p>{% endcodeblock %}</p>

<p>{% codeblock sign2.ejs lang:html %}
&lt;!DOCTYPE html&gt;</p>
<html>
  <head>
    <title>&lt;%= title %&gt;</title>
    <link rel="stylesheet" href="http://lighter.tw/stylesheets/style.css" />
  </head>
  <body>
    <h1>Show Result</h1>
    <p>Accout:&lt;%= account%&gt;</p>
    <p>Password:&lt;%= pass%&gt;</p>
  </body>
</html>
<p>{% endcodeblock %}</p>

<p>程式碼放在這：<a href="https://github.com/lighter/test">下載</a></p>

<h2 id="section">參考資料</h2>
<p><a href="http://book.nodejs.tw/zh-tw/node_express.html">Express 介紹</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NodeJS and Socket.io chat]]></title>
    <link href="http://lighter.tw/blog/2012/08/26/nodejs-and-socket-dot-io-chat/"/>
    <updated>2012-08-26T08:48:00+08:00</updated>
    <id>http://lighter.tw/blog/2012/08/26/nodejs-and-socket-dot-io-chat</id>
    <content type="html"><![CDATA[<p>有了簡單的聊天室的概念(<a href="http://lighter.github.com/blog/2012/08/24/simple-chat-with-socket-dot-io/">Simple Chat With Socket.io</a>)之後，我就在想，那同時有很多人時，要如何知道現在線上有誰呢？還有每次發言的人是誰呢？有了這些想法，那就開始繼續修改程式碼吧。</p>

<h2 id="client">Client端</h2>

<p>我將程式碼拆解幾個部分來看，先從Client端來看，一開始是引入<code>bootstrap</code>、<code>jQuery</code>等基本的<code>html</code>宣告
{% codeblock index.html lang:html %}
&lt;!DOCTYPE html&gt;</p>
<html>
<head>
<link rel="stylesheet" href="http://current.bootstrapcdn.com/bootstrap-v204/css/bootstrap-combined.min.css" type="text/css" />
<script src="http://lighter.tw/socket.io/socket.io.js"></script>
<script src="http://lighter.tw//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
{% endcodeblock %}

再來就是<code>javascript</code>的部份，可看到<code>socket.on</code>監聽的是<code>connect</code>事件，當開啟網頁連現實，會呼應到Server端的<code>add_user</code>事件，並且執行<code>prompt()</code>。這邊暫且先不看到Server端，繼續往下看下去。

{% codeblock index.html lang:javascript %}
<script>
var socket = io.connect('http://localhost:8080');

//Part 1
//一連線時執行
socket.on('connect', function(){
  socket.emit('add_user', prompt("What's your name"));
});
{% endcodeblock %}

當有位新的使用者加入時，目前線上所有使用者，勢必要更新，而使用者列表更新，需透過Server端告知Clint端要執行更新的動作因此在Client的程式碼如下：

下面程式碼可看到<code>update_chat_content</code>如同之前的方式加入對話內容([Here](http://lighter.github.com/blog/2012/08/24/simple-chat-with-socket-dot-io/))；接著<code>update_user</code>一開始先清空使用者列表所有內容，使用<code>$.each</code>一一將使用者重新加入列表中。

{% codeblock index.html lang:javascript %}
//Part 2
//update_chat_content
socket.on('update_chat_content', function(user_name, data){

  //由Server端emit 'update_chat_content' 更新談話內容
  $('#chat_content').append('<div>' + user_name + ':' + data + '</div>');
});

//update_user
socket.on('update_user', function(data){

  //先清空所有使用名稱
  $("#users").empty();

  //將data取出，使用each的方法一個一個將使用者重新加入列表
  $.each(data, function(key, value){
    $("#users").append('<div>' + value + '</div>');
  });

});
{% endcodeblock %}

最後則是發送對話按鈕的觸發事件以及HTML的部份。

{% codeblock index.html lang:javascript %}
//Part 3
$(function(){
  $("#send").on('click', function(){

    //取得input text欄位的值後，將欄位內容清除
    var message = $("#send_input").val();
    $("#send_input").val('');

    //呼叫Server端的emit 'send_chat'
    socket.emit('send_chat', message);
  });
});
</script>
</head>
<body>

<div class="container-fluid">
  <div class="row-fluid">
    <div class="span2" id="users">
      <!--Sidebar content-->
    </div>
    <div class="span10">
      <!--Body content-->
      <div class="span12" id="chat_content"></div>
      <div class="input-append">
      <input class="span2" id="send_input" size="16" type="text" /><button class="btn" type="button" id="send">Send!</button>
      </div>
    </div>
  </div>
</div>

</body>
</html>
<p>{% endcodeblock %}</p>

<h2 id="server">Server端</h2>
<p>Server端主要的情況有3個：</p>

<p>1.當Client發送對話訓時</p>

<p>2.當有新加入的使用者時</p>

<p>3.當使用者關閉網頁時</p>

<p>程式碼如下，當有新加入的使用者會呼叫Server端的<code>add_user</code>事件，Server端會將新加入的使用者加入到socket的session內，並呼叫Client端執行<code>update_chat_content</code>事件，並傳遞兩個參數，這是要用來讓Client端知道有新加入的使用者，例如當Tony加入時，在Client端頁面會顯示<code>SERVER:Tomy has connected</code>的訊息告知。其餘的就說明都寫在程式碼的註解上了，直接看程式碼可能會更清楚。</p>

<p>{% codeblock Server.js lang:javascript %}
var http = require(‘http’),
    fs = require(‘fs’),
    server,
    io;</p>

<p>server = http.createServer(function(req, res){
  fs.readFile(__dirname + ‘/index.html’, function(err, data){
    res.writeHead(200, {‘Content-Type’: ‘text/html’});
    res.end(data);
  });
});</p>

<p>server.listen(8080);</p>

<p>//使用者名稱
var user_name = {};</p>

<p>io = require(‘socket.io’).listen(server);</p>

<p>//連線時會執行的內容
io.sockets.on(‘connection’, function(socket){</p>

<p>//當client端emit ‘send_chat’ 時執行
  socket.on(‘send_chat’, function(data){
    io.sockets.emit(‘update_chat_content’, socket.user_name, data);
  });</p>

<p>//當client端emit ‘add_user’ 時執行
  socket.on(‘add_user’, function(user_name){</p>

<pre><code>//儲存user_name到socket session
socket.user_name = user_name;

//加入user_name 到 user_name list
user_name[user_name] = user_name;

//呼叫Client端的 update_chat事件
socket.emit('update_chat_content', 'SERVER:', socket.user_name + ' has connected');

//呼叫所有Client端的 update_chat事件
socket.broadcast.emit('update_chat_content', 'SERVER:',user_name + ' has connected');

//呼叫Client端的 update_user事件
io.sockets.emit('update_user', user_name);   });
</code></pre>

<p>//當Client端斷線時執行
  socket.on(‘disconnect’, function(){</p>

<pre><code>//從user_name list中刪除使用者
delete user_name[socket.user_name];

//呼叫Client端的 update_user事件更新使用者列表
io.sockets.emit('update_user', user_name);

//廣播所有Client端的 update_chat_content事件，通知某某使用者離線
socket.broadcast.emit('update_chat_content', 'SERVER:', socket.user_name + ' has disconnected');   }); }); {% endcodeblock %}
</code></pre>

<h2 id="section">參考資料</h2>

<p><a href="http://psitsmike.com/2011/09/node-js-and-socket-io-chat-tutorial/">node.js and socket.io chat tutorial</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple chat with Socket.io]]></title>
    <link href="http://lighter.tw/blog/2012/08/24/simple-chat-with-socket-dot-io/"/>
    <updated>2012-08-24T13:32:00+08:00</updated>
    <id>http://lighter.tw/blog/2012/08/24/simple-chat-with-socket-dot-io</id>
    <content type="html"><![CDATA[<p>如果已我所學不多的情況下要製作一個簡單的聊天室，我大概能想到的方法就是將這些對話內容存入MySql，然後背後透過Ajax一直去撈取資料庫的內容然後一直更新畫面上的對話內容，這樣想想就覺得好麻煩…</p>

<p>最近看到Socket.io這簡直真是好用，下面是一個簡單的聊天室程式碼。</p>

<h2 id="server">Server端</h2>
<p>{% codeblock Server.js lang:javascript %}
var http = require(‘http’),
    fs = require(‘fs’),
    server,
    io;</p>

<p>server = http.createServer(function(req, res){
  fs.readFile(__dirname + ‘/index.html’, function(err, data){
    res.writeHead(200, {‘Content-Type’: ‘text/html’});
    res.end(data);
  });
});</p>

<p>server.listen(8080);
io = require(‘socket.io’).listen(server);</p>

<p>//連線時會執行的內容
io.sockets.on(‘connection’, function(socket){</p>

<p>//當client端emit ‘send_chat’時執行
  socket.on(‘send_chat’, function(data){
    io.sockets.emit(‘update_chat_content’, data);
  });</p>

<p>});
{% endcodeblock %}</p>

<h2 id="client">Client端</h2>
<p>{% codeblock index.html lang:html %}
&lt;!DOCTYPE html&gt;</p>
<html>
<head>
<link rel="stylesheet" href="http://current.bootstrapcdn.com/bootstrap-v204/css/bootstrap-combined.min.css" type="text/css" />
<script src="http://lighter.tw/socket.io/socket.io.js"></script>
<script src="http://lighter.tw//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
<script>
 var socket = io.connect('http://localhost:8080');
 socket.on('update_chat_content', function(data){

  //由Server端emit 'update_chat_content' 更新談話內容
  $('#chat_content').append('<div>' + data + '</div>');
 });
 
 $(function(){
  $("#send").on('click', function(){

    //取得input text欄位的值後，將欄位內容清除
    var message = $("#send_input").val();
    $("#send_input").val('');

    //呼叫Server端的emit 'send_chat'
    socket.emit('send_chat', message);
  });
 });
</script>
</head>
<body>

<div class="row-fluid" style="text-align: center">
  <div class="span12" id="chat_content"></div>
  <div class="input-append">
    <input class="span2" id="send_input" size="16" type="text" /><button class="btn" type="button" id="send">Send!</button>
  </div>
</div>

</body>
</html>
<p>{% endcodeblock %}</p>

<p>其實只要觀察一下<code>socket.emit</code>與<code>socket.on</code>裡面監聽的名稱就可以看出Server端與Client的執行時間順序了；最後執行<code>node Server.js</code>就可以看到一個簡單的聊天室。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Socket.io]]></title>
    <link href="http://lighter.tw/blog/2012/08/23/socket-dot-io/"/>
    <updated>2012-08-23T01:56:00+08:00</updated>
    <id>http://lighter.tw/blog/2012/08/23/socket-dot-io</id>
    <content type="html"><![CDATA[<p><a href="http://socket.io/">Socket.io</a>的目的是提供即時通訊的套件，在官方網站上可以看到一些簡單的範例程式碼，但是我還是記錄一下簡單的操作。首先必須安裝Socket.io。</p>

<p>{% codeblock %}
npm install socket.io
{% endcodeblock %}</p>

<p>Server端程式碼
{% codeblock server.js lang:javascript %}
var http = require(‘http’),
    fs = require(‘fs’),
    server,
    io;</p>

<p>server = http.createServer(function(req, res){
  fs.readFile(__dirname + ‘/index.html’, function(err, data){
    res.writeHead(200);
    res.end(data);
  });
});</p>

<p>server.listen(8080);</p>

<p>//引入socket.io並且聽取server的服務
io = require(‘socket.io’).listen(server);</p>

<p>//當連線時(connection)執行的動作
io.sockets.on(‘connection’, function(socket){</p>

<p>//讓Client端監聽’news’方法，並傳送值({hello:’world’})
  socket.emit(‘news’, {hello:’world’});</p>

<p>//監聽Client發送的’my other event’，並將Client端發送的值印出
  socket.on(‘my other event’, function(data){
    console.log(data);
  });
});
{% endcodeblock %}</p>

<p>Server端與Client端對照<code>.on</code>與<code>.emit</code>兩個方法內的名稱，可看出Server端與Client的互相對應關係。</p>

<p>Client端
{% codeblock index.html lang:html %}
<script src="http://lighter.tw/socket.io/socket.io.js"></script>
<script>
 var socket = io.connect('http://localhost:8080');
 socket.on('news', function(data){
  console.log(data);
  socket.emit('my other event', {my: 'data'});
 });
</script>
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
