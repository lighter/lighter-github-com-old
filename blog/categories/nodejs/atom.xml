<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: NodeJS | Lighter's Blog]]></title>
  <link href="http://lighter.github.com/blog/categories/nodejs/atom.xml" rel="self"/>
  <link href="http://lighter.github.com/"/>
  <updated>2012-10-31T09:55:40+08:00</updated>
  <id>http://lighter.github.com/</id>
  <author>
    <name><![CDATA[Willy lighter]]></name>
    <email><![CDATA[apple.xva@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[NodeJS and Socket.io chat]]></title>
    <link href="http://lighter.github.com/blog/2012/08/26/nodejs-and-socket-dot-io-chat/"/>
    <updated>2012-08-26T08:48:00+08:00</updated>
    <id>http://lighter.github.com/blog/2012/08/26/nodejs-and-socket-dot-io-chat</id>
    <content type="html"><![CDATA[<p>有了簡單的聊天室的概念(<a href="http://lighter.github.com/blog/2012/08/24/simple-chat-with-socket-dot-io/">Simple Chat With Socket.io</a>)之後，我就在想，那同時有很多人時，要如何知道現在線上有誰呢？還有每次發言的人是誰呢？有了這些想法，那就開始繼續修改程式碼吧。</p>

<h2>Client端</h2>

<p>我將程式碼拆解幾個部分來看，先從Client端來看，一開始是引入<code>bootstrap</code>、<code>jQuery</code>等基本的<code>html</code>宣告
{% codeblock index.html lang:html %}
&lt;!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="http://current.bootstrapcdn.com/bootstrap-v204/css/bootstrap-combined.min.css" type="text/css" /></p>

<script src='http://lighter.github.com/socket.io/socket.io.js'></script>


<script src="http://lighter.github.com//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>


<p>{% endcodeblock %}</p>

<p>再來就是<code>javascript</code>的部份，可看到<code>socket.on</code>監聽的是<code>connect</code>事件，當開啟網頁連現實，會呼應到Server端的<code>add_user</code>事件，並且執行<code>prompt()</code>。這邊暫且先不看到Server端，繼續往下看下去。</p>

<p>{% codeblock index.html lang:javascript %}</p>

<script>
var socket = io.connect('http://localhost:8080');

//Part 1
//一連線時執行
socket.on('connect', function(){
  socket.emit('add_user', prompt("What's your name"));
});
{% endcodeblock %}

當有位新的使用者加入時，目前線上所有使用者，勢必要更新，而使用者列表更新，需透過Server端告知Clint端要執行更新的動作因此在Client的程式碼如下：

下面程式碼可看到<code>update_chat_content</code>如同之前的方式加入對話內容([Here](http://lighter.github.com/blog/2012/08/24/simple-chat-with-socket-dot-io/))；接著<code>update_user</code>一開始先清空使用者列表所有內容，使用<code>$.each</code>一一將使用者重新加入列表中。

{% codeblock index.html lang:javascript %}
//Part 2
//update_chat_content
socket.on('update_chat_content', function(user_name, data){

  //由Server端emit 'update_chat_content' 更新談話內容
  $('#chat_content').append('<div>' + user_name + ':' + data + '</div>');
});

//update_user
socket.on('update_user', function(data){

  //先清空所有使用名稱
  $("#users").empty();

  //將data取出，使用each的方法一個一個將使用者重新加入列表
  $.each(data, function(key, value){
    $("#users").append('<div>' + value + '</div>');
  });

});
{% endcodeblock %}

最後則是發送對話按鈕的觸發事件以及HTML的部份。

{% codeblock index.html lang:javascript %}
//Part 3
$(function(){
  $("#send").on('click', function(){

    //取得input text欄位的值後，將欄位內容清除
    var message = $("#send_input").val();
    $("#send_input").val('');

    //呼叫Server端的emit 'send_chat'
    socket.emit('send_chat', message);
  });
});
</script>


<p></head>
<body></p>

<div class="container-fluid">
  <div class="row-fluid">
    <div class="span2" id="users">
      <!--Sidebar content-->
    </div>
    <div class="span10">
      <!--Body content-->
      <div class="span12" id="chat_content"></div>
      <div class="input-append">
      <input class="span2" id="send_input" size="16" type="text"><button class="btn" type="button" id="send">Send!</button>
      </div>
    </div>
  </div>
</div>


<p></body>
</html>
{% endcodeblock %}</p>

<h2>Server端</h2>

<p>Server端主要的情況有3個：</p>

<p>1.當Client發送對話訓時</p>

<p>2.當有新加入的使用者時</p>

<p>3.當使用者關閉網頁時</p>

<p>程式碼如下，當有新加入的使用者會呼叫Server端的<code>add_user</code>事件，Server端會將新加入的使用者加入到socket的session內，並呼叫Client端執行<code>update_chat_content</code>事件，並傳遞兩個參數，這是要用來讓Client端知道有新加入的使用者，例如當Tony加入時，在Client端頁面會顯示<code>SERVER:Tomy has connected</code>的訊息告知。其餘的就說明都寫在程式碼的註解上了，直接看程式碼可能會更清楚。</p>

<p>{% codeblock Server.js lang:javascript %}
var http = require('http'),</p>

<pre><code>fs = require('fs'),
server,
io;
</code></pre>

<p>server = http.createServer(function(req, res){
  fs.readFile(__dirname + '/index.html', function(err, data){</p>

<pre><code>res.writeHead(200, {'Content-Type': 'text/html'});
res.end(data);
</code></pre>

<p>  });
});</p>

<p>server.listen(8080);</p>

<p>//使用者名稱
var user_name = {};</p>

<p>io = require('socket.io').listen(server);</p>

<p>//連線時會執行的內容
io.sockets.on('connection', function(socket){</p>

<p>  //當client端emit 'send_chat' 時執行
  socket.on('send_chat', function(data){</p>

<pre><code>io.sockets.emit('update_chat_content', socket.user_name, data);
</code></pre>

<p>  });</p>

<p>  //當client端emit 'add_user' 時執行
  socket.on('add_user', function(user_name){</p>

<pre><code>//儲存user_name到socket session
socket.user_name = user_name;

//加入user_name 到 user_name list
user_name[user_name] = user_name;

//呼叫Client端的 update_chat事件
socket.emit('update_chat_content', 'SERVER:', socket.user_name + ' has connected');

//呼叫所有Client端的 update_chat事件
socket.broadcast.emit('update_chat_content', 'SERVER:',user_name + ' has connected');

//呼叫Client端的 update_user事件
io.sockets.emit('update_user', user_name);
</code></pre>

<p>  });</p>

<p>  //當Client端斷線時執行
  socket.on('disconnect', function(){</p>

<pre><code>//從user_name list中刪除使用者
delete user_name[socket.user_name];

//呼叫Client端的 update_user事件更新使用者列表
io.sockets.emit('update_user', user_name);

//廣播所有Client端的 update_chat_content事件，通知某某使用者離線
socket.broadcast.emit('update_chat_content', 'SERVER:', socket.user_name + ' has disconnected');
</code></pre>

<p>  });
});
{% endcodeblock %}</p>

<h2>參考資料</h2>

<p><a href="http://psitsmike.com/2011/09/node-js-and-socket-io-chat-tutorial/">node.js and socket.io chat tutorial</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple chat with Socket.io]]></title>
    <link href="http://lighter.github.com/blog/2012/08/24/simple-chat-with-socket-dot-io/"/>
    <updated>2012-08-24T13:32:00+08:00</updated>
    <id>http://lighter.github.com/blog/2012/08/24/simple-chat-with-socket-dot-io</id>
    <content type="html"><![CDATA[<p>如果已我所學不多的情況下要製作一個簡單的聊天室，我大概能想到的方法就是將這些對話內容存入MySql，然後背後透過Ajax一直去撈取資料庫的內容然後一直更新畫面上的對話內容，這樣想想就覺得好麻煩…</p>

<p>最近看到Socket.io這簡直真是好用，下面是一個簡單的聊天室程式碼。</p>

<h2>Server端</h2>

<p>{% codeblock Server.js lang:javascript %}
var http = require('http'),</p>

<pre><code>fs = require('fs'),
server,
io;
</code></pre>

<p>server = http.createServer(function(req, res){
  fs.readFile(__dirname + '/index.html', function(err, data){</p>

<pre><code>res.writeHead(200, {'Content-Type': 'text/html'});
res.end(data);
</code></pre>

<p>  });
});</p>

<p>server.listen(8080);
io = require('socket.io').listen(server);</p>

<p>//連線時會執行的內容
io.sockets.on('connection', function(socket){</p>

<p>  //當client端emit 'send_chat'時執行
  socket.on('send_chat', function(data){</p>

<pre><code>io.sockets.emit('update_chat_content', data);
</code></pre>

<p>  });</p>

<p>});
{% endcodeblock %}</p>

<h2>Client端</h2>

<p>{% codeblock index.html lang:html %}
&lt;!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="http://current.bootstrapcdn.com/bootstrap-v204/css/bootstrap-combined.min.css" type="text/css" /></p>

<script src='http://lighter.github.com/socket.io/socket.io.js'></script>


<script src="http://lighter.github.com//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>


<script>
 var socket = io.connect('http://localhost:8080');
 socket.on('update_chat_content', function(data){

  //由Server端emit 'update_chat_content' 更新談話內容
  $('#chat_content').append('<div>' + data + '</div>');
 });
 
 $(function(){
  $("#send").on('click', function(){

    //取得input text欄位的值後，將欄位內容清除
    var message = $("#send_input").val();
    $("#send_input").val('');

    //呼叫Server端的emit 'send_chat'
    socket.emit('send_chat', message);
  });
 });
</script>


<p></head>
<body></p>

<div class="row-fluid" style="text-align: center">
  <div class="span12" id="chat_content"></div>
  <div class="input-append">
    <input class="span2" id="send_input" size="16" type="text"><button class="btn" type="button" id="send">Send!</button>
  </div>
</div>


<p></body>
</html>
{% endcodeblock %}</p>

<p>其實只要觀察一下<code>socket.emit</code>與<code>socket.on</code>裡面監聽的名稱就可以看出Server端與Client的執行時間順序了；最後執行<code>node Server.js</code>就可以看到一個簡單的聊天室。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Socket.io]]></title>
    <link href="http://lighter.github.com/blog/2012/08/23/socket-dot-io/"/>
    <updated>2012-08-23T01:56:00+08:00</updated>
    <id>http://lighter.github.com/blog/2012/08/23/socket-dot-io</id>
    <content type="html"><![CDATA[<p><a href="http://socket.io/">Socket.io</a>的目的是提供即時通訊的套件，在官方網站上可以看到一些簡單的範例程式碼，但是我還是記錄一下簡單的操作。首先必須安裝Socket.io。</p>

<p>{% codeblock %}
npm install socket.io
{% endcodeblock %}</p>

<p>Server端程式碼
{% codeblock server.js lang:javascript %}
var http = require('http'),</p>

<pre><code>fs = require('fs'),
server,
io;
</code></pre>

<p>server = http.createServer(function(req, res){
  fs.readFile(__dirname + '/index.html', function(err, data){</p>

<pre><code>res.writeHead(200);
res.end(data);
</code></pre>

<p>  });
});</p>

<p>server.listen(8080);</p>

<p>//引入socket.io並且聽取server的服務
io = require('socket.io').listen(server);</p>

<p>//當連線時(connection)執行的動作
io.sockets.on('connection', function(socket){</p>

<p>  //讓Client端監聽'news'方法，並傳送值({hello:'world'})
  socket.emit('news', {hello:'world'});</p>

<p>  //監聽Client發送的'my other event'，並將Client端發送的值印出
  socket.on('my other event', function(data){</p>

<pre><code>console.log(data);
</code></pre>

<p>  });
});
{% endcodeblock %}</p>

<p>Server端與Client端對照<code>.on</code>與<code>.emit</code>兩個方法內的名稱，可看出Server端與Client的互相對應關係。</p>

<p>Client端
{% codeblock index.html lang:html %}</p>

<script src='http://lighter.github.com/socket.io/socket.io.js'></script>


<script>
 var socket = io.connect('http://localhost:8080');
 socket.on('news', function(data){
  console.log(data);
  socket.emit('my other event', {my: 'data'});
 });
</script>


<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NodeJS]]></title>
    <link href="http://lighter.github.com/blog/2012/08/10/nodejs/"/>
    <updated>2012-08-10T13:34:00+08:00</updated>
    <id>http://lighter.github.com/blog/2012/08/10/nodejs</id>
    <content type="html"><![CDATA[<p><a href="http://nodejs.org/">Node.js</a>使以Javascript語言為基礎的框架，讓我覺得很神奇的是它可以拿來做網站，以往在寫網頁時是使用需要使用php、Apache、MySQL；而Node.js可以直接建立網站，真的蠻酷的！</p>

<p>安裝完Node.js，在桌面上建立一個<code>hello.js</code>的檔案，程式碼內容如下
{% codeblock hello.js lang:javascript %}
var http = require('http');</p>

<p>http.createServer(function(req, res) {</p>

<pre><code>res.writeHead(200, {'Content-Type': 'text/plain'});
res.end('Hello World');
</code></pre>

<p>}}.listen(8000);
{% endcodeblock %}</p>

<p>接著在終端機切換到該檔案的路徑下輸入
{% codeblock %}
$ node hello.js
{% endcodeblock %}</p>

<p>開啟瀏覽器網址輸入http://127.0.0.1:8000，即可看到一個Hello World，就這麼簡單，但讓我覺得很厲害的地方是終端機使用，看到有人將終端機的操作透過Node.js即時的反應呈現在網路上！</p>

<p>目前我也發現<code>Express</code>這個套件，這套件讓開發http server變得容易許多，修改<code>hello.js</code>(使用Express)。
{% codeblock hello.js lang:javascript %}
var app = require('express').createServer();
app.get('/', function(req, res) {</p>

<pre><code>res.send('Hello World');
</code></pre>

<p>});
app.listen(8000);
{% endcodeblock %}
上面的程式碼可看到<code>app</code>還可以定義HTTP的路由，此例為<code>app.get</code>。</p>

<h2>參考資料</h2>

<p><a href="http://nodejs.org/">Node.js</a></p>

<p><a href="http://book.nodejs.tw/">Node.js 中文電子書</a></p>

<p><a href="http://www.csser.com/board/4f77e6f996ca600f78000936">Express.js 中文入門指引手冊</a></p>
]]></content>
  </entry>
  
</feed>
